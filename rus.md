#Используйте короткие селекторы
Есть одно *очень* важное проверенное правило: в то время, как сайты становятся 
больше, селекторы должны становиться короче.

Я говорю о том, что, если вы хотите создавать расширяемые и масштабируемые, 
гибкие и предсказуемые сайты, вы должны всерьез заботиться о том, чтобы ваши 
CSS-селекторы были как можно более удобными для разработчиков, т.е. короткими.

Уменьшение длины селекторов помогает во многом:

* Увеличивает эффективность селекторов
* Снижает зависимость от контекста
* Улучшает переносимость
* Снижает риск ошибки в селекторе
* Снижает специфичность
* Может сделать код более прощающим

Этот список не лишен неопределенности, поэтому я рассмотрю каждый из пунктов по 
порядку. Вы увидите, что между ними много общего (например, снижение 
зависимости от расположения в сущности означает улучшение переносимости ваших 
селекторов), но каждый из них имеет право на существование сам по себе.

##Увеличивает эффективность селекторов
Я уже писал ранее об эффективности CSS-селекторов. В этой статье я обойду 
вниманием многие аспекты, поэтому для полного понимания я рекомендую вам 
сначала прочесть статью [Составление эффективных CSS-селекторов](http://csswizardry.com/2011/09/writing-efficient-css-selectors/).

Не обращая внимания на некоторые конкретные селекторы (`*{}` - это обычно самый 
медленный селектор, в зависимости от того, как он используется; идентификаторы 
являются самыми быстрыми, за ними следуют классы; контекстные селекторы 
сравнительно медленны, а за ними идут псевдоселекторы), мы можем с уверенностью 
сказать, что короткие селекторы работают быстрее.

Это станет понятно, если сравнить 2 селектора:

~~~~ .language-css
html body .header .nav{}  
.nav{}  
~~~~

Вполне ясно, что в первом примере браузер должен учитывать выполнение 4 
условий: принадлежность к классу `.nav`, затем к классу `.header`, затем к 
элементу `body` и затем, наконец, к элементу `html` (браузеры читают селекторы 
справа налево).

Во втором примере браузеру нужно проверить выполнение только одного условия: 
соответствия классу `.nav`. Браузеру нужно сделать *в четыре раза* меньше 
работы, чтобы проверить совпадение селектора. Каждый раз, когда вы составляете 
селектор, попробуйте сократить его, насколько это возможно без потерь. Вместо 
`ul.nav{}` (2 проверки) используйте `.nav{}` (1 проверка). Вместо `.nav li a{}` 
(3 проверки) используйте `.nav a{}` (2 проверки).

[Производительность селекторов выросла, и это уже не то, о чем нам *действительно* стоит волноваться](http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/), 
но это не означает, что мы должны действовать нерационально. Я уверен, что 
никто из нас не будет переживать о потере £5, но мы ведь не готовы засовывать 
банкноты в шреддер... Понятие эффективности селекторов *существует*, и вы 
можете увеличить их эффективность там, где сделать это **очень просто**. 

##Снижает зависимость от контекста
Сокращая длину селекторов, вы захотите снизить число контекстных (например, 
`.sidebar .promo{}`) и дочерних селекторов (например, `.sidebar > .promo{}`). 
Избегая контекстных селекторов, вы избавляете элемент от необходимости 
находиться внутри другого элемента. Давайте еще раз рассмотрим пример с 
`.sidebar .promo{}`...

Имея селектор вида `.sidebar .promo{}`, мы говорим, что хотим указать на любой 
элемент с классом `.promo` внутри элемента с классом `.sidebar`. Это означает, 
что мы ограничиваем применение этих стилей только внутри определенного 
элемента – мы зависим от расположения элементов.

Заменив `.sidebar .promo{}` на что-нибудь вроде `.secondary-promo{}`, мы 
получаем возможность располжить элемент практически *где угодно*, где бы нам 
этого ни хотелось. Теперь мы можем расположить его не только в боковой панели, 
как раньше, но и в подвале или в шапке страницы, или даже после статьи.

Снижая уровень вложенности, мы можем существенно снизить зависимость от 
расположения элементов и повысить переносимость кода...

##Улучшает переносимость
Итак, теперь мы не привязаны к селекторам, зависящим от контекста, и мы 
понимаем, что наши компоненты обладают большей переносимостью. Мы можем легко 
перемещать элементы, потому что работа нашего CSS-кода зависит не от того, где 
они расположены, а только от того, существуют ли они. Круто!

Другой способ улучшить переносимость - это не уточнять селекторы. Уточненный 
селектор - это селектор вида `ul.nav{}` или `a.button{}` или `div.content{}`.

Использование уточненных селекторов - это плохо, потому что они снижают 
эффективность (больше проверок, чем нам на самом деле нужно), а также (и это 
гораздо важнее) потому что они привязывают нас к конкретным элементам. Мы 
больше не можем, например, применить класс `.button` для элемента `<input>` 
или `<button>`. Мы не можем [применить класс `.nav` к `<ol>`, чтобы реализоать "хлебные крошки"](http://csswizardry.com/2011/09/the-nav-abstraction/).

**Селекторы должны быть элементо-независимыми**. Вашему CSS-коду должно быть все 
равно, к какому элементу вы хотите применить ваши стили.

Еще один способ улучшить переносимость селекторов - это *полностью* отказаться 
от использования селекторов по элементу. Вот пример:

~~~~ .language-css
/\* Основные стили для виджета \*/  
.widget{}   	

/\* Стилизация заголовков виджета \*/  
.widget > h2{}  
~~~~

Здесь у нас есть проблемный селектор; что, если этот `<h2>` необходимо будет 
заменить на `<h3>`? Что, если нам необходимо будет добавить другой `<h2>`, не 
являющийся заголовком, в качестве дочернего элемента для `.widget`? Мы составили 
очень негибкий и непереносимый селектор. Вместо этого нам следует сделать так:

~~~~ .language-css
/\* Основные стили для виджета \*/  
.widget{}  

/\* Стилизация заголовков виджета \*/  
.widget-title{}  
~~~~

Теперь мы можем применить `.widget-title` к *любому* элементу - например, к 
`<h4>` — и можем использовать в виджете сколько угодно `<h4>` без классов и без 
применения к ним стилей заголовков. Круто!

##Снижает риск ошибки в селекторе
Чем длиннее селектор, тем в выполнении большего количества условий необходимо 
убедиться браузеру, прежде чем он сможет применить его. Чем больше проверок, 
тем, ествественно, больше шанс, что что-то пойдет не так.

Избыточный селектор вида `body > div:nth-of-type(2) > article:first-child > 
p:first-child{}` — взятый из моего доклада [Ломаем хорошие привычки](https://speakerdeck.com/u/csswizardry/p/breaking-good-habits?slide=15)
 - содержит *10* проверок; десять условий, которые должны выполниться, чтобы 
 браузер смог выбрать элемент.

Достаточно, чтобы расоложение `div:nth-of-type(2)` изменилось, или чтобы 
`p:first-child` заменили на `blockquote`, или чтобы `article:first-child` 
перестал быть дочерним элементом `div:nth-of-type(2)`, или произошла *любая 
другая* ошибка - и селектор перестанет работать. Простая замена этого селектора 
на класс `.intro{}` означает, что ошибка может случиться только в одном месте, 
а вероятность этого близка к нулю (нужно специально удалить этот класс из кода, 
чтобы браузер не нашел совпадений).

Более короткие селекторы имеют по статистике меньший шанс ошибки.

##Снижает специфичность
Это очень важно! Вот, что на самом деле имеет значение!

Более длинные селекторы имеют большую специфичность. Специфичность селекторов - 
это ночной кошмар и **вам следует снижать ее, насколько это возможно**. Мы уже 
знаем, что мы [не используем идентификаторы в CSS](http://csswizardry.com/2011/09/when-using-ids-can-be-a-pain-in-the-class/), 
но цепочка селекторов зачастую так же плоха.

Селекторы вида `.widget > h2{}` имеют большую специфичность (наряду с другими 
указанными проблемами), чем селекторы вида `.widget-title{}`.

`.nav li a{}` имеет большую специфичность, чем `.nav a` (а также менее 
эффективен). Снижение длины селектора снижает его специфичность, и это **очень 
важно**. Высокая специфичность ведет к непрерывной конкуретной борьбе между 
селекторами, которая может быть выиграна только при использовании 
дополнительных, *более специфичных*, селекторов (или использованием 
`!important`, но в таком случае - позор вам). Это ужасно. Самый простой способ 
снизить специфичность (после *полного отказа от использования идентификаторов в 
CSS*) это отказ от использования длинных селекторов.

##Может сделать код более прощающим
Это очень специфичный, но и очень хороший пример того, как коротные селекторы 
могут сделать код более прощающим. Тем не менее, должен предупредить, что вы 
можете рассмотреть с двух сторон то, о чем я собираюсь вам рассказать; вы 
можете утверждать, что код становится более гибким и может изящно обрабатывать 
ошибки **или** вы можете утверждать, что код слишком снисходителен к ошибкам. 
Тем не менее, вот вам реальная история...

Работая над достаточно крупным проектом в Sky, я придерживался своих правил, 
когда реализовывал (вертикальную) навигационную панель с помощью CSS следующим 
образом:

~~~~ .language-css
.nav{ /\* Стили для навигации \*/ }  
  
/\* Заметьте, что я не использовал стили для .nav li, так как это была 
вертикальная панель. \*/  
  
.nav a{ display:block; /\* Дополнительные стили \*/ }  
~~~~

В CMS была ошибка, которая привела к тому, что генерируемая разметка выглядела 
вот так:

~~~~ .language-html
<ul class=nav> 
    <a href=#></a>  
    <a href=#></a>  
    <a href=#></a>  
    <a href=#></a>  
</ul>
~~~~

Заметили ошибку? Нет `<li>`! Это совсем не круто, но, так как я использовал 
`.nav a{}` вместо `.nav li a{}`, ничего не сломалось. Мой код был более 
снисходительным к ошибкам, чем если бы я добавил эту третью проверку.

Ну, это не делает разметку правильной, и *позволяет* использовать худшую 
разметку, чем при использовании более подробного селектора, но вы можете 
увидеть, насколько CSS может быть толерантным к ошибкам разметки.

Как я и говорил, вы можете занять любую сторону. Более подробный селектор 
означал бы, что мы бы сразу же заметили ошибку в CMS, потому что для `<a>` не 
применились бы никакие стили. Но! В то же время наш CSS был достаточно гибким, 
чтобы не обращать на это внимание. Выводы делайте сами, а я займу нейтральную 
позицию, будучи немного разочарован тем, что ошибка в CMS не была замечена. Это 
очень специфичный пример того, как более короткие селекторы могут привести к 
использованию более прощающего CSS.

##В заключение
Я говорил, что это правило я применял к большим сайтам, но, честно говоря, вам 
стоит применять его везде. Правило, о котором мы говорим, становится все более 
важным (а неприменение его сказывается очень болезненно) на больших проектах, 
но оно определенно, *определенно* поможет вам на проектах любых размеров, 
больших и маленьких.

Итак, при использовании большего количества классов и меньшего числа потомков, 
сохраняя селекторы короткими, переносимыми и элементо-независимыми, и, в целом, 
принимая во внимание необходимость поддержки и возможности изменения при 
написании CSS, мы можем действительно просто улучшить качество нашего кода до 
бесконечности. Мы можем сделать вещи более эффективными, более прощающими, 
более гибкими и удобными для повторного использования, просто пересмотрев один 
из наиболее простых и фундаментальных аспектов CSS - наши селекторы.